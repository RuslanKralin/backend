# Порядок выполнения проекта

### 1. Общий npm пакет (ticket-for-cinema-service)

**Зачем:** Чтобы все наши сервисы использовали одинаковые утилиты, типы и настройки форматирования.
**Что сделали:** Создали пакет с prettier, утилитами и общими типами, который можно устанавливать в любой сервис.

### 2. Gateway-service - наш главный вход

**Зачем:** Это точка входа для всех пользователей, которая будет перенаправлять запросы в другие сервисы.
**Что сделали:**

- Настроили базовый запуск сервера
- Включили CORS (чтобы фронтенд мог обращаться к API)
- Добавили HealthCheck (проверка что сервис работает)
- Настроили Swagger (документация API в браузере)

### 3. gRPC контракты между сервисами

**Зачем:** Чтобы сервисы могли общаться друг с другом по быстрому протоколу gRPC.
**Что сделали:**

- Создали файл `auth.proto` - это как договор между сервисами
- Описали там все возможные запросы и ответы (отправка OTP, проверка OTP)
- Сгенерировали TypeScript типы из этого файла
- Опубликовали в npm пакет чтобы все сервисы использовали одни и те же типы

### 4. Настройка gRPC общения

**Зачем:** Auth Service и Gateway должны понимать друг друга.
**Что сделали:**

- Настроили gRPC клиент в Gateway (он может отправлять запросы в Auth)
- Настроили gRPC сервер в Auth Service (он принимает запросы от Gateway)
- Теперь они могут обмениваться данными по gRPC протоколу

### 5. Docker-compose для всех сервисов

**Зачем:** Чтобы легко запускать все сервисы вместе.
**Что сделали:** Создали общий контейнер, который запускает Gateway, Auth Service, PostgreSQL и Redis одной командой.

### 6. Prisma ORM в Auth Service

**Зачем:** Чтобы удобно работать с базой данных PostgreSQL.
**Что сделали:**

- Установили Prisma и клиент для PostgreSQL
- Создали `schema.prisma` - файл где описана структура нашей базы
- Настроили подключение к базе через `.env` файл
- Теперь можем работать с базой через удобные TypeScript функции

### 7. Redis для хранения OTP кодов

**Зачем:** OTP коды нужно хранить временно и быстро получать доступ.
**Что сделали:**

- Подключили Redis как временное хранилище
- Настроили подключение с хостом localhost и портом 6379
- Теперь OTP коды хранятся в Redis с временем жизни (TTL)

### 8. Полная логика верификации OTP

**Зачем:** Основная функция нашего сервиса - проверка OTP кодов.
**Что сделали:**

- Создали эндпоинт для отправки OTP (генерирует 6-значный код, хеширует и сохраняет в Redis)
- Создали эндпоинт для проверки OTP (сравнивает введенный код с сохраненным)
- Если код верный - обновляем статус верификации пользователя
- Возвращаем access и refresh токены

### 9. Централизованная обработка ошибок

**Зачем:** Ошибки из Auth Service приходят в gRPC формате, а пользователю нужны понятные HTTP ошибки.
**Что сделали:**

- Создали `GlobalExceptionFilter` - это как универсальный переводчик ошибок
- Он ловит абсолютно все ошибки в Gateway
- gRPC ошибку "5 NOT_FOUND: Invalid code" превращает в HTTP 404 с сообщением "Invalid code"
- Все ошибки теперь в одном формате и легко читаются в Swagger

### 10. Общие типы и enum'ы для всех сервисов

**Зачем:** Чтобы все сервисы говорили на одном языке.
**Что сделали:**

- Создали папку `common/lib/enums` для общих перечислений (статусы, типы ошибок и т.д.)
- Настроили там package.json и TypeScript
- Это будет опубликовано в npm пакет чтобы все сервисы использовали одни и те же типы

### 11. Кастомная валидация переменных окружения

**Зачем:** Чтобы убедиться что все необходимые переменные (.env файлы) настроены правильно при запуске.
**Что планируем:** Создать отдельный пакет `common/lib/env` который будет проверять что все переменные существуют и имеют правильный формат.

---

    это триггер для комита
    git commit --allow-empty -m "trigger: test with new commit"
