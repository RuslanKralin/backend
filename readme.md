# Порядок выполнения проекта

### 1. Общий npm пакет (ticket-for-cinema-service)

**Зачем:** Чтобы все наши сервисы использовали одинаковые утилиты, типы и настройки форматирования.
**Что сделали:** Создали пакет с prettier, утилитами и общими типами, который можно устанавливать в любой сервис.

### 2. Gateway-service - наш главный вход

**Зачем:** Это точка входа для всех пользователей, которая будет перенаправлять запросы в другие сервисы.
**Что сделали:**

- Настроили базовый запуск сервера
- Включили CORS (чтобы фронтенд мог обращаться к API)
- Добавили HealthCheck (проверка что сервис работает)
- Настроили Swagger (документация API в браузере)

### 3. gRPC контракты между сервисами

**Зачем:** Чтобы сервисы могли общаться друг с другом по быстрому протоколу gRPC.
**Что сделали:**

- Создали файл `auth.proto` - это как договор между сервисами
- Описали там все возможные запросы и ответы (отправка OTP, проверка OTP)
- Сгенерировали TypeScript типы из этого файла
- Опубликовали в npm пакет чтобы все сервисы использовали одни и те же типы

### 4. Настройка gRPC общения

**Зачем:** Auth Service и Gateway должны понимать друг друга.
**Что сделали:**

- Настроили gRPC клиент в Gateway (он может отправлять запросы в Auth)
- Настроили gRPC сервер в Auth Service (он принимает запросы от Gateway)
- Теперь они могут обмениваться данными по gRPC протоколу

### 5. Docker-compose для всех сервисов

**Зачем:** Чтобы легко запускать все сервисы вместе.
**Что сделали:** Создали общий контейнер, который запускает Gateway, Auth Service, PostgreSQL и Redis одной командой.

### 6. Prisma ORM в Auth Service

**Зачем:** Чтобы удобно работать с базой данных PostgreSQL.
**Что сделали:**

- Установили Prisma и клиент для PostgreSQL
- Создали `schema.prisma` - файл где описана структура нашей базы
- Настроили подключение к базе через `.env` файл
- Теперь можем работать с базой через удобные TypeScript функции

### 7. Redis для хранения OTP кодов

**Зачем:** OTP коды нужно хранить временно и быстро получать доступ.
**Что сделали:**

- Подключили Redis как временное хранилище
- Настроили подключение с хостом localhost и портом 6379
- Теперь OTP коды хранятся в Redis с временем жизни (TTL)

### 8. Полная логика верификации OTP

**Зачем:** Основная функция нашего сервиса - проверка OTP кодов.
**Что сделали:**

- Создали эндпоинт для отправки OTP (генерирует 6-значный код, хеширует и сохраняет в Redis)
- Создали эндпоинт для проверки OTP (сравнивает введенный код с сохраненным)
- Если код верный - обновляем статус верификации пользователя
- Возвращаем access и refresh токены

### 9. Централизованная обработка ошибок

**Зачем:** Ошибки из Auth Service приходят в gRPC формате, а пользователю нужны понятные HTTP ошибки.
**Что сделали:**

- Создали `GlobalExceptionFilter` - это как универсальный переводчик ошибок
- Он ловит абсолютно все ошибки в Gateway
- gRPC ошибку "5 NOT_FOUND: Invalid code" превращает в HTTP 404 с сообщением "Invalid code"
- Все ошибки теперь в одном формате и легко читаются в Swagger

### 10. Общие типы и enum'ы для всех сервисов

**Зачем:** Чтобы все сервисы говорили на одном языке.
**Что сделали:**

- Создали папку `common/lib/enums` для общих перечислений (статусы, типы ошибок и т.д.)
- Настроили там package.json и TypeScript
- Это будет опубликовано в npm пакет чтобы все сервисы использовали одни и те же типы

### 11. Кастомная валидация переменных окружения

**Зачем:** Чтобы убедиться что все необходимые переменные (.env файлы) настроены правильно при запуске.
**Что планируем:** Создать отдельный пакет `common/lib/env` который будет проверять что все переменные существуют и имеют правильный формат.

---

    это триггер для комита
    git commit --allow-empty -m "trigger: test with new commit"

### 12. Собственная система токенов (Passport Token)

**Зачем:** Создать простую и безопасную систему токенов без зависимостей от JWT библиотек.
**Что сделали:**

- Создали пакет `passport` с собственной системой генерации и проверки токенов
- Токен состоит из 4 частей: `userId.iat.exp.signature`
- **userId** - ID пользователя в base64Url
- **iat** - время создания в timestamp (base64Url)
- **exp** - время истечения в timestamp (base64Url)
- **signature** - HMAC подпись от объединенных данных

**Как работает:**

```typescript
// Генерация токена
const token = generateToken(secretKey, userId, ttlInSeconds);
// Результат: dXNlcklkLWFzZGFzYXNk.MTc2Nzc5NDM0Ng.MTc2Nzc5Nzk0Ng.6y8wzZbBlK2I6L0mSkXyjyr/XnGniFnczW9zcjh7Eas=

// Проверка токена
const result = verifyToken(secretKey, token);
// Результат: { valid: true, userId: 'userId-asdasasd' }
```

**Безопасность:**

- HMAC подпись с секретным ключом - нельзя подделать
- `constantTimeEqual` - защита от timing attacks
- Проверка срока действия - токены автоматически истекают
- Base64Url кодировка - безопасно для URL

**Структура файлов:**

```
passport/lib/
├── index.ts          # основные функции generateToken/verifyToken
├── utils/
│   ├── base64.ts     # base64UrlEncode/Decode для URL-безопасности
│   └── crypto.ts     # constantTimeEqual для защиты от атак
```

**Преимущества перед JWT:**

- ✅ Полный контроль над форматом и логикой
- ✅ Меньше зависимостей (только Node.js crypto)
- ✅ Простая отладка - все части токена читаемы
- ✅ Легко расширить дополнительными полями
- ✅ Быстрее чем стандартные JWT библиотеки

### 13. Динамический модуль

yarn add @nestjs/common @nestjs/core reflect-metadata txjs
после создания я его подключил в auth-service и теперь там генерируются access и refresh токены методами из моего пакета passport который я опубликовал в npm

### 14. Установка refresh токена в куки на gateway service

```bash
yarn add cookie-parser
yarn add -D @types/cookie-parser
```

**Настройка защиты куки:**
1. `httpOnly: true` - защита от XSS атак (скрипт не может прочитать куки)
2. `secure: true` (в production) - передача куки только по HTTPS
3. `sameSite: 'lax'` - защита от CSRF атак
4. `domain: configService.get('COOKIES_DOMAIN')` - ограничение домена
5. `maxAge: 30 дней` - время жизни refresh токена
6. `signed: true` с COOKIES_SECRET - защита от подмены куки

**Пример кода:**
```typescript
res.cookie('refreshToken', refreshToken, {
  httpOnly: true,     // Защита от XSS
  secure: process.env.NODE_ENV === 'production', // Только HTTPS в продакшене
  sameSite: 'lax',    // Защита от CSRF
  domain: configService.get('COOKIES_DOMAIN'),
  maxAge: 30 * 24 * 60 * 60 * 1000, // 30 дней
  signed: true        // Подпись куки
});
```

**Кратко об атаках:**
- **XSS (Cross-Site Scripting)**: Вредоносный код на странице.
  *Защита:* `httpOnly` блокирует доступ JavaScript к куки.
  
- **CSRF (Cross-Site Request Forgery)**: Подмена запросов с других сайтов.
  *Защита:* `sameSite: 'lax'` ограничивает отправку кук.

- **Подмена кук**: Изменение значений кук.
  *Защита:* `signed: true` с COOKIES_SECRET.

- **Перехват кук**: В открытой сети.
  *Защита:* `secure: true` (HTTPS).

- **Утечка на поддоменах**:
  *Защита:* Ограничение `domain`.

### 15. Обновление токенов
1. нужно изменить контракты в contracts (auth.proto добаить метод обновления токенов) 
После реализации обновления токена, мы получаем новую пару access/refresh токенов и обновляем куки с новым refresh токеном.

### 16. logout
очистка куки

### 17. Реализация guards и decorators для защиты эндпоинтов где нужна авторизация
тут мы соблюдаем SRP и не пихаем их в нашу библиотеку passport (она только создает токен, проверяет и возвращает userId, подписывает, декодирует, проверяет что он не подделан )
